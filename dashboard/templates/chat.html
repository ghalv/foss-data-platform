<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat - FOSS Data Platform</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .chat-container { height: 65vh; overflow-y: auto; background: #f8f9fa; border-radius: 0.5rem; }
        .message { max-width: 80%; }
        .message.user { background: #0d6efd; color: #fff; border-radius: 1rem 1rem 0.25rem 1rem; }
        .message.assistant { background: #ffffff; border: 1px solid #e9ecef; border-radius: 1rem 1rem 1rem 0.25rem; }
        .chat-input { border-radius: 2rem; }
        .chat-actions button { border-radius: 2rem; }

        /* Enhanced progress card animations */
        @keyframes pulse-subtle {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.95; }
        }

        @keyframes shimmer {
            0% { background-position: -200px 0; }
            100% { background-position: calc(200px + 100%) 0; }
        }

        .animated-bg .progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        .completed-step {
            background-color: #d4edda !important;
            color: #155724 !important;
            border: 1px solid #c3e6cb;
        }

        /* Step indicators */
        .step-indicator {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .step-indicator.completed {
            background-color: #d4edda;
            color: #155724;
            border: 2px solid #28a745;
        }

        .step-indicator.current {
            background-color: #cce7ff;
            color: #0056b3;
            border: 2px solid #007bff;
            animation: pulse-current 1.5s infinite;
        }

        .step-indicator.pending {
            background-color: #f8f9fa;
            color: #6c757d;
            border: 2px solid #dee2e6;
        }

        @keyframes pulse-current {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Progress shimmer effect */
        .progress-shimmer {
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Enhanced UI blocks */
        .ui-blocks-container {
            margin-top: 1rem;
            border-top: 1px solid #e9ecef;
            padding-top: 1rem;
            width: 100%;
            max-width: 100%;
        }

        /* Make UI blocks wider and more spacious */
        .ui-blocks-container .mb-2 {
            width: 100%;
            max-width: 100%;
        }

        .ui-blocks-container .ui-block-metric,
        .ui-blocks-container .ui-block-list {
            width: 100%;
            max-width: 100%;
        }

        .ui-block-metric {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border: 2px solid transparent !important;
        }

        .ui-block-metric:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .ui-block-list {
            border-left: 4px solid #ffc107 !important;
            max-height: 150px;
            overflow-y: auto;
        }

        .ui-block-list .list-group-item {
            padding: 0.5rem 0.75rem;
            border: none;
            border-bottom: 1px solid #f8f9fa;
        }

        .ui-block-list .list-group-item:last-child {
            border-bottom: none;
        }

        /* Typing dots animation */
        .typing-dots { display: inline-flex; gap: 6px; align-items: center; }
        .typing-dot { width: 6px; height: 6px; border-radius: 50%; background: #adb5bd; opacity: 0.7; animation: typingBounce 1.2s infinite ease-in-out; }
        .typing-dot:nth-child(2) { animation-delay: 0.15s; }
        .typing-dot:nth-child(3) { animation-delay: 0.3s; }
        @keyframes typingBounce {
            0%, 80%, 100% { transform: translateY(0); opacity: 0.6; }
            40% { transform: translateY(-4px); opacity: 1; }
        }
    </style>
    </head>
<body class="bg-light">
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="/"><i class="fas fa-database"></i> FOSS Data Platform</a>
            <div class="navbar-nav ms-auto">
                <a class="nav-link" href="/"><i class="fas fa-home"></i> Dashboard</a>
                <a class="nav-link" href="/pipeline-management"><i class="fas fa-cogs"></i> Pipelines</a>
                <a class="nav-link" href="/data-browser"><i class="fas fa-search"></i> Data</a>
                <a class="nav-link" href="/health"><i class="fas fa-heartbeat"></i> Health</a>
                <a class="nav-link active" href="/chat"><i class="fas fa-comments"></i> Chat</a>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <div class="row mb-3">
            <div class="col">
                <h1 class="display-5"><i class="fas fa-comments text-primary"></i> Chat</h1>
                <p class="lead text-muted">Ask the assistant to manage pipelines, query data, or check system status.</p>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div id="chat" class="chat-container p-3 mb-3 border"></div>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="input-group rounded-pill overflow-hidden">
                    <input id="chatInput" class="form-control chat-input border-0" type="text" placeholder="Type a message (e.g., 'Run the Stavanger Parking pipeline')" />
                    <button id="sendBtn" class="btn btn-primary"><i class="fas fa-paper-plane me-1"></i> Send</button>
                </div>
            </div>
        </div>

        
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js"></script>
    <script>
        const chatEl = document.getElementById('chat');
        const inputEl = document.getElementById('chatInput');
        const sendBtn = document.getElementById('sendBtn');
        const clearBtn = null;
        const history = [];
        let isThinking = false;

        function updateSendState() {
            const hasText = inputEl.value.trim().length > 0;
            const shouldEnable = hasText && !isThinking;
            sendBtn.disabled = !shouldEnable;
        }

        function appendMessage(role, text, uiBlocks) {
            const row = document.createElement('div');
            row.className = 'd-flex mb-2 ' + (role === 'user' ? 'justify-content-end' : 'justify-content-start');
            const bubble = document.createElement('div');
            bubble.className = 'p-2 message ' + (role === 'user' ? 'user' : 'assistant');

            // Add text content
            if (text) {
                console.log('Processing text:', text); // Debug
                if (role === 'assistant') {
                    try {
                        // Clean up text formatting and standardize font sizes
                        let cleanText = text.replace(/\n\s*\n/g, '\n').trim();
                        const html = marked.parse(cleanText);
                        let sanitized = DOMPurify.sanitize(html);

                        // Standardize font sizes in markdown content
                        sanitized = sanitized
                            .replace(/<h1>/g, '<h1 style="font-size: 1.5rem; margin: 0.5rem 0;">')
                            .replace(/<h2>/g, '<h2 style="font-size: 1.3rem; margin: 0.4rem 0;">')
                            .replace(/<h3>/g, '<h3 style="font-size: 1.2rem; margin: 0.3rem 0;">')
                            .replace(/<h4>/g, '<h4 style="font-size: 1.1rem; margin: 0.3rem 0;">')
                            .replace(/<h5>/g, '<h5 style="font-size: 1rem; margin: 0.2rem 0;">')
                            .replace(/<h6>/g, '<h6 style="font-size: 0.95rem; margin: 0.2rem 0;">')
                            .replace(/<p>/g, '<p style="font-size: 0.95rem; margin: 0.25rem 0; line-height: 1.4;">')
                            .replace(/<li>/g, '<li style="font-size: 0.9rem; margin: 0.1rem 0;">')
                            .replace(/<strong>/g, '<strong style="font-weight: 600;">')
                            .replace(/<em>/g, '<em style="font-style: italic;">');

                        console.log('Generated HTML:', sanitized); // Debug
                        bubble.innerHTML = sanitized;
                    } catch (e) {
                        console.error('Markdown parsing error:', e); // Debug
                        bubble.textContent = text;
                    }
                } else {
                    bubble.textContent = text;
                }
            }

            // Add UI blocks if present
            if (uiBlocks && uiBlocks.length > 0) {
                console.log('üé® Rendering UI blocks:', uiBlocks); // Debug
                const blocksDiv = document.createElement('div');
                blocksDiv.className = 'mt-3 ui-blocks-container';
                blocksDiv.style.border = '1px solid #e9ecef';
                blocksDiv.style.borderRadius = '8px';
                blocksDiv.style.padding = '1rem';
                blocksDiv.style.backgroundColor = '#f8f9fa';
                blocksDiv.style.marginTop = '1rem';

                uiBlocks.forEach((block, index) => {
                    console.log(`üîß Creating block ${index}:`, block); // Debug
                    try {
                        const blockEl = createUIBlock(block);
                        if (blockEl) {
                            console.log(`‚úÖ Adding block ${index} to DOM:`, blockEl); // Debug
                            blocksDiv.appendChild(blockEl);
                        } else {
                            console.error('‚ùå Failed to create UI block:', block); // Debug
                            // Create a fallback error block
                            const errorBlock = document.createElement('div');
                            errorBlock.className = 'alert alert-danger mt-2';
                            errorBlock.textContent = `Error creating ${block.type} block`;
                            blocksDiv.appendChild(errorBlock);
                        }
                    } catch (error) {
                        console.error(`üí• Exception creating block ${index}:`, error);
                        const errorBlock = document.createElement('div');
                        errorBlock.className = 'alert alert-danger mt-2';
                        errorBlock.textContent = `Exception creating ${block.type} block: ${error.message}`;
                        blocksDiv.appendChild(errorBlock);
                    }
                });
                console.log('üéØ Final blocks container:', blocksDiv); // Debug

                bubble.appendChild(blocksDiv);
            } else {
                console.log('üì≠ No UI blocks to render'); // Debug
            }

            row.appendChild(bubble);
            chatEl.appendChild(row);
            chatEl.scrollTop = chatEl.scrollHeight;
            return row; // return element for optional later updates
        }

        function createUIBlock(block) {
            console.log('Creating UI block of type:', block.type, block); // Debug
            const blockDiv = document.createElement('div');
            blockDiv.className = 'mb-2 p-2 border rounded';
            blockDiv.style.backgroundColor = '#ffffff'; // Ensure visibility

            if (block.type === 'progress') {
                blockDiv.className += ' border-primary bg-light position-relative';
                blockDiv.setAttribute('data-operation-id', block.operation_id);
                blockDiv.style.minHeight = '120px';

                const context = block.context || {};
                const estimatedTime = context.estimated_time || 'Varies';
                const steps = context.steps || [];
                const progress = block.progress || 0;

                // Add animated background for running operations
                const animatedBg = block.status === 'running' ? 'animated-bg' : '';

                // Create dynamic step indicators
                const stepIndicators = steps.map((step, index) => {
                    const stepProgress = (100 / steps.length) * index;
                    const isCompleted = index < Math.floor(progress / (100 / steps.length));
                    const isCurrent = !isCompleted && index === Math.floor(progress / (100 / steps.length));

                    return `
                        <div class="d-flex align-items-center mb-2">
                            <div class="step-indicator ${isCompleted ? 'completed' : isCurrent ? 'current' : 'pending'}">
                                ${isCompleted ? '‚úì' : isCurrent ? '‚ü≥' : '‚óã'}
                            </div>
                            <span class="ms-2 small ${isCompleted ? 'text-success' : isCurrent ? 'text-primary fw-bold' : 'text-muted'}">
                                ${step}
                            </span>
                        </div>
                    `;
                }).join('');

                blockDiv.innerHTML = `
                    <div class="d-flex justify-content-between align-items-start mb-3">
                        <div>
                            <h6 class="mb-1 fw-bold text-primary">${block.title}</h6>
                            <div class="small text-muted">‚è±Ô∏è ${estimatedTime}</div>
                        </div>
                        <div class="text-end">
                            <div class="badge ${block.status === 'running' ? 'bg-primary' : block.status === 'completed' ? 'bg-success' : 'bg-danger'} mb-1">
                                ${block.status === 'running' ? 'üîÑ' : block.status === 'completed' ? '‚úÖ' : '‚ùå'}
                                <span class="ms-1">${block.status === 'running' ? 'Running' : block.status === 'completed' ? 'Done' : 'Error'}</span>
                            </div>
                            <div class="small text-muted">${progress}% complete</div>
                        </div>
                    </div>

                    <div class="progress mb-3 ${animatedBg}" style="height: 14px; border-radius: 7px; box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);">
                        <div class="progress-bar bg-${block.status === 'running' ? 'primary' : block.status === 'completed' ? 'success' : 'danger'}"
                             role="progressbar"
                             style="width: ${progress}%; border-radius: 7px; transition: width 0.5s ease; position: relative;">
                            ${block.status === 'running' ? '<div class="progress-shimmer"></div>' : ''}
                        </div>
                    </div>

                    <div class="mb-2">
                        <div class="fw-semibold text-dark mb-2">${block.message || 'Initializing...'}</div>
                        ${steps.length > 0 ? `
                            <div class="steps-container mt-2">
                                ${stepIndicators}
                            </div>
                        ` : ''}
                    </div>

                    ${block.show_details && context.description ? `
                        <div class="small text-muted border-top pt-2 mt-2" style="background: rgba(0,123,255,0.05); padding: 8px; border-radius: 4px;">
                            <strong>What this does:</strong><br>
                            ${context.description}
                        </div>
                    ` : ''}
                `;

                // Add CSS animation for running operations
                if (block.status === 'running') {
                    blockDiv.style.animation = 'pulse-subtle 2s infinite';
                }
            } else if (block.type === 'metric') {
                console.log('Creating metric block:', block); // Debug
                blockDiv.className += ` border-${block.color || 'primary'} bg-light ui-block-metric`;
                blockDiv.style.border = `2px solid var(--bs-${block.color || 'primary'})`;
                blockDiv.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <div class="fw-bold text-${block.color || 'primary'}">${block.title}</div>
                            ${block.subtitle ? `<div class="small text-muted">${block.subtitle}</div>` : ''}
                        </div>
                        <div class="text-end">
                            <div class="h4 mb-0 text-${block.color || 'primary'} fw-bold">${block.value}</div>
                            ${block.unit ? `<div class="small text-muted">${block.unit}</div>` : ''}
                        </div>
                    </div>
                `;
                console.log('Created metric block HTML:', blockDiv.innerHTML); // Debug
            } else if (block.type === 'table') {
                blockDiv.className += ' border-info bg-light';
                blockDiv.innerHTML = `
                    <h6 class="mb-2 text-info fw-bold">${block.title}</h6>
                    <div class="table-responsive">
                        <table class="table table-sm table-hover">
                            <thead class="table-light">
                                <tr>
                                    ${block.columns.map(col => `<th class="fw-semibold">${col}</th>`).join('')}
                                </tr>
                            </thead>
                            <tbody>
                                ${block.rows.map(row =>
                                    `<tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>`
                                ).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            } else if (block.type === 'list') {
                const colorClass = block.color || 'warning';
                const iconClass = colorClass === 'danger' ? 'fa-exclamation-triangle' :
                                colorClass === 'success' ? 'fa-check-circle' :
                                'fa-exclamation-circle';
                blockDiv.className += ` border-${colorClass} bg-light ui-block-list`;
                blockDiv.innerHTML = `
                    <h6 class="mb-2 text-${colorClass} fw-bold">${block.title}</h6>
                    <ul class="list-group list-group-flush">
                        ${block.items.map(item => `<li class="list-group-item d-flex align-items-start bg-transparent border-0 px-0">
                            <i class="fas ${iconClass} text-${colorClass} me-2 mt-1"></i>
                            <span class="flex-grow-1">${item}</span>
                        </li>`).join('')}
                    </ul>
                    <div style="margin-bottom: 1rem;"></div>
                `;
            } else if (block.type === 'info') {
                const colorClass = block.color || 'info';
                const iconClass = colorClass === 'danger' ? 'fa-exclamation-triangle' :
                                colorClass === 'warning' ? 'fa-exclamation-circle' :
                                'fa-info-circle';
                blockDiv.className += ` border-${colorClass} bg-light`;
                let debugHtml = '';
                if (block.debug) {
                    debugHtml = `<div class="mt-2 p-2 bg-dark text-light rounded small font-monospace" style="font-size: 0.75rem;">
                        <strong>üîß Debug:</strong><br>
                        ${Array.isArray(block.debug) ? block.debug.join('<br>') : block.debug}
                    </div>`;
                }
                blockDiv.innerHTML = `
                    <div class="d-flex align-items-start">
                        <i class="fas ${iconClass} text-${colorClass} me-2 mt-1"></i>
                        <div class="flex-grow-1">
                            <strong class="text-${colorClass}">${block.title}</strong>
                            <div class="small mt-1">${block.content}</div>
                            ${debugHtml}
                        </div>
                    </div>
                `;
            }

            return blockDiv;
        }

        let typingRow = null;
        function showTyping() {
            if (typingRow) return;
            typingRow = document.createElement('div');
            typingRow.className = 'd-flex mb-2 justify-content-start';
            const bubble = document.createElement('div');
            bubble.className = 'p-2 message assistant';
            bubble.innerHTML = '<div class="typing-dots"><span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span></div>';
            typingRow.appendChild(bubble);
            chatEl.appendChild(typingRow);
            chatEl.scrollTop = chatEl.scrollHeight;
        }
        function hideTyping() {
            if (typingRow && typingRow.parentNode) typingRow.parentNode.removeChild(typingRow);
            typingRow = null;
        }

        // Progress tracking for long-running operations
        let activeProgressIntervals = new Map();

        function startProgressTracking(operationId, messageEl) {
            if (activeProgressIntervals.has(operationId)) {
                clearInterval(activeProgressIntervals.get(operationId));
            }

            // Do an immediate first update
            let firstUpdate = true;

            const progressInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/chat/progress/${operationId}`);
                    if (!response.ok) {
                        clearInterval(progressInterval);
                        activeProgressIntervals.delete(operationId);
                        return;
                    }

                    const progressData = await response.json();

                    // For the first update, ensure we show the latest progress immediately
                    if (firstUpdate) {
                        firstUpdate = false;
                        // Update progress bar immediately with current progress
                        const progressBlock = messageEl.querySelector(`[data-operation-id="${operationId}"]`);
                        if (progressBlock) {
                            const progressBar = progressBlock.querySelector('.progress-bar');
                            const messageDiv = progressBlock.querySelector('.small.text-muted');

                            if (progressBar && progressData.progress !== undefined) {
                                progressBar.style.width = `${progressData.progress}%`;
                                progressBar.setAttribute('aria-valuenow', progressData.progress);
                            }

                            if (messageDiv && progressData.message) {
                                messageDiv.textContent = progressData.message;
                            }
                        }
                    }

                    // Update progress UI
                    const progressBlock = messageEl.querySelector(`[data-operation-id="${operationId}"]`);
                    if (progressBlock) {
                        if (progressData.completed) {
                            // Operation completed - clear interval but keep the card visible
                            clearInterval(progressInterval);
                            activeProgressIntervals.delete(operationId);

                            // Update progress card to show completion status
                            const statusBadge = progressBlock.querySelector('.badge');
                            const progressBar = progressBlock.querySelector('.progress-bar');
                            const messageDiv = progressBlock.querySelector('.small.text-muted');

                            // Force completion state immediately
                            if (progressBar) {
                                progressBar.style.width = '100%';
                                progressBar.setAttribute('aria-valuenow', 100);
                                progressBar.className = `progress-bar bg-${progressData.success ? 'success' : 'danger'}`;
                                // Clear any transition animations
                                progressBar.style.transition = 'none';
                            }

                            if (statusBadge) {
                                const isSuccess = progressData.success;
                                statusBadge.textContent = isSuccess ? '‚úÖ Done' : '‚ùå Failed';
                                statusBadge.className = `badge bg-${isSuccess ? 'success' : 'danger'}`;
                            }

                            // Ensure all progress elements are updated immediately
                            setTimeout(() => {
                                if (progressBar) {
                                    progressBar.style.width = '100%';
                                    progressBar.setAttribute('aria-valuenow', 100);
                                    progressBar.className = `progress-bar bg-${progressData.success ? 'success' : 'danger'}`;
                                }
                            }, 50);

                            if (messageDiv) {
                                if (progressData.success) {
                                    messageDiv.textContent = 'Operation completed successfully';
                                    messageDiv.style.color = '#28a745';
                                } else {
                                    messageDiv.textContent = 'Operation failed - detailed error information shown below';
                                    messageDiv.style.color = '#dc3545';
                                    messageDiv.style.fontWeight = 'bold';
                                }
                            }

                            // Ensure error details are displayed prominently in the UI blocks
                            if (!progressData.success && progressData.ui_blocks && progressData.ui_blocks.length > 0) {
                                // Add a prominent error summary at the top
                                const errorSummary = {
                                    type: 'info',
                                    title: '‚ùå Operation Failed',
                                    content: 'Detailed error information is shown below. Please review the failed tests and error analysis for troubleshooting steps.',
                                    color: 'danger'
                                };
                                progressData.ui_blocks.unshift(errorSummary);

                                // Add specific error details if available
                                if (progressData.error_details) {
                                    progressData.ui_blocks.splice(1, 0, {
                                        type: 'info',
                                        title: 'üîç Error Details',
                                        content: progressData.error_details,
                                        color: 'warning'
                                    });
                                }
                            } else if (!progressData.success) {
                                // If no UI blocks, create a basic error block
                                progressData.ui_blocks = [{
                                    type: 'info',
                                    title: '‚ùå Operation Failed',
                                    content: progressData.error_details || 'The operation failed. Please check the server logs for more details.',
                                    color: 'danger'
                                }];
                            }

                            // Force a final update to ensure all elements are updated
                            setTimeout(() => {
                                if (progressBar) {
                                    if (progressBar.style.width !== '100%') {
                                        progressBar.style.width = '100%';
                                        progressBar.setAttribute('aria-valuenow', 100);
                                    }

                                    // Remove animation for failed operations to stop the spinning effect
                                    if (!progressData.success) {
                                        progressBar.style.animation = 'none';
                                        // Add a subtle pulse effect instead
                                        progressBar.style.boxShadow = '0 0 10px rgba(220, 53, 69, 0.5)';
                                    }
                                }
                            }, 100);

                            // Update message with final results
                            const textEl = messageEl.querySelector('.message');
                            if (textEl && progressData.reply) {
                                // If the reply contains new information, append it
                                if (progressData.reply && progressData.reply !== textEl.textContent) {
                                    textEl.innerHTML += '<br><br>' + progressData.reply.replace(/\n/g, '<br>');
                                }
                            }

                            // Add final results UI blocks if they exist
                            if (progressData.ui_blocks && progressData.ui_blocks.length > 0) {
                                const blocksContainer = messageEl.querySelector('.message > div:last-child');
                                if (blocksContainer) {
                                    // Keep existing progress block and add new blocks after it
                                    progressData.ui_blocks.forEach(block => {
                                        const blockEl = createUIBlock(block);
                                        if (blockEl) {
                                            blocksContainer.appendChild(blockEl);
                                        }
                                    });
                                }
                            }

                            // Update conversation history
                            const lastAssistantMsg = history[history.length - 1];
                            if (lastAssistantMsg && lastAssistantMsg.role === 'assistant') {
                                lastAssistantMsg.content = progressData.reply || lastAssistantMsg.content;
                            }

                        } else {
                            // Update progress bar and message
                            const progressBar = progressBlock.querySelector('.progress-bar');
                            const statusBadge = progressBlock.querySelector('.badge');
                            const messageDiv = progressBlock.querySelector('.small.text-muted');

                            if (progressBar) {
                                progressBar.style.width = `${progressData.progress || 0}%`;
                                progressBar.setAttribute('aria-valuenow', progressData.progress || 0);
                            }

                            if (statusBadge) {
                                const status = progressData.status;
                                statusBadge.textContent = status === 'running' ? 'üîÑ Running' :
                                                         status === 'completed' ? '‚úÖ Done' : '‚ùå Error';
                                statusBadge.className = `badge bg-${status === 'running' ? 'primary' :
                                                                       status === 'completed' ? 'success' : 'danger'}`;
                            }

                            if (messageDiv) {
                                messageDiv.textContent = progressData.message || 'Processing...';
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error polling progress:', error);

                    // Count consecutive errors
                    if (!window.progressErrors) window.progressErrors = new Map();
                    const errorCount = (window.progressErrors.get(operationId) || 0) + 1;
                    window.progressErrors.set(operationId, errorCount);

                    // If we've had 3 consecutive errors, show error state
                    if (errorCount >= 3) {
                        clearInterval(progressInterval);
                        activeProgressIntervals.delete(operationId);
                        window.progressErrors.delete(operationId);

                        // Update UI to show connection error
                        const progressBlock = messageEl.querySelector(`[data-operation-id="${operationId}"]`);
                        if (progressBlock) {
                            const statusBadge = progressBlock.querySelector('.badge');
                            const messageDiv = progressBlock.querySelector('.small.text-muted');

                            if (statusBadge) {
                                statusBadge.textContent = 'üîå Connection Error';
                                statusBadge.className = 'badge bg-danger';
                            }

                            if (messageDiv) {
                                messageDiv.textContent = '‚ö†Ô∏è Connection lost - operation may still be running';
                                messageDiv.style.color = '#ffc107';
                                messageDiv.style.fontWeight = 'bold';
                            }

                            // Add troubleshooting information within the card
                            const cardBody = progressBlock.closest('.card-body');
                            if (cardBody && !cardBody.querySelector('.error-details')) {
                                const errorDiv = document.createElement('div');
                                errorDiv.className = 'error-details mt-2 p-2 bg-light rounded border';
                                errorDiv.innerHTML = `
                                    <small class="text-muted">
                                        <strong>üîç Troubleshooting Steps:</strong><br>
                                        ‚Ä¢ Check server logs: <code>docker-compose logs dashboard</code><br>
                                        ‚Ä¢ Verify operation status manually<br>
                                        ‚Ä¢ Try refreshing the page<br>
                                        ‚Ä¢ Contact administrator if issues persist
                                    </small>
                                `;
                                cardBody.appendChild(errorDiv);
                            }
                        }
                    }
                }
            }, 2000); // Poll every 2 seconds

            activeProgressIntervals.set(operationId, progressInterval);

            // Set a timeout for the operation (10 minutes = 600,000ms)
            const operationTimeout = setTimeout(() => {
                if (activeProgressIntervals.has(operationId)) {
                    console.warn(`Operation ${operationId} timed out`);
                    clearInterval(progressInterval);
                    activeProgressIntervals.delete(operationId);

                    // Update UI to show timeout
                    const progressBlock = messageEl.querySelector(`[data-operation-id="${operationId}"]`);
                    if (progressBlock) {
                        const statusBadge = progressBlock.querySelector('.badge');
                        const messageDiv = progressBlock.querySelector('.small.text-muted');
                        const progressBar = progressBlock.querySelector('.progress-bar');

                        if (statusBadge) {
                            statusBadge.textContent = '‚è∞ Timeout';
                            statusBadge.className = 'badge bg-warning';
                        }

                        if (messageDiv) {
                            messageDiv.textContent = '‚ö†Ô∏è Operation timed out - may still be running in background';
                            messageDiv.style.color = '#ffc107';
                            messageDiv.style.fontWeight = 'bold';
                        }

                        if (progressBar) {
                            progressBar.style.width = '100%';
                            progressBar.className = 'progress-bar bg-warning';
                        }

                        // Add timeout troubleshooting info
                        const cardBody = progressBlock.closest('.card-body');
                        if (cardBody && !cardBody.querySelector('.timeout-details')) {
                            const timeoutDiv = document.createElement('div');
                            timeoutDiv.className = 'timeout-details mt-2 p-2 bg-warning bg-opacity-10 rounded border border-warning';
                            timeoutDiv.innerHTML = `
                                <small class="text-muted">
                                    <strong>‚è∞ Operation Timeout:</strong><br>
                                    ‚Ä¢ Long-running operations may continue in background<br>
                                    ‚Ä¢ Check server status: <code>docker-compose ps</code><br>
                                    ‚Ä¢ Monitor logs: <code>docker-compose logs -f dashboard</code><br>
                                    ‚Ä¢ Try the operation again if needed
                                </small>
                            `;
                            cardBody.appendChild(timeoutDiv);
                        }
                    }
                }
            }, 600000); // 10 minutes timeout
        }

        async function sendMessage() {
            if (isThinking) return; // block while processing
            const text = inputEl.value.trim();
            if (!text) return;
            appendMessage('user', text, undefined);
            history.push({ role: 'user', content: text });
            inputEl.value = '';
            isThinking = true;
            updateSendState();
            showTyping();
            async function doRequest() {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 30000);
                const res = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: text,
                        messages: history.slice(-10)
                    }),
                    signal: controller.signal
                }).finally(() => clearTimeout(timeout));
                if (!res.ok) {
                    hideTyping();
                    const errText = await res.text();
                    const errorBlocks = [{
                        type: 'info',
                        title: '‚ùå Request Error',
                        content: `HTTP ${res.status}: ${errText.substring(0, 200)}`,
                        color: 'danger'
                    }];
                    appendMessage('assistant', 'An error occurred while processing your request.', errorBlocks);
                    return;
                }
                let data;
                try {
                    data = await res.json();
                } catch (e) {
                    hideTyping();
                    const raw = await res.text();
                    const errorBlocks = [{
                        type: 'info',
                        title: '‚ùå Response Error',
                        content: `Invalid response format: ${raw.substring(0, 200)}`,
                        color: 'warning'
                    }];
                    appendMessage('assistant', 'Received an invalid response from the server.', errorBlocks);
                    return;
                }
                hideTyping();
                if (data.success) {
                    const messageEl = appendMessage('assistant', data.reply, data.ui_blocks);
                    history.push({ role: 'assistant', content: data.reply });

                    // Handle long-running operations with progress tracking
                    if (data.operation_id) {
                        startProgressTracking(data.operation_id, messageEl);

                        // For fast operations, do an immediate progress check
                        setTimeout(() => {
                            fetch(`/api/chat/progress/${data.operation_id}`)
                                .then(response => response.json())
                                .then(progressData => {
                                    const progressBlock = messageEl.querySelector(`[data-operation-id="${data.operation_id}"]`);
                                    if (progressBlock && progressData.progress !== undefined) {
                                        const progressBar = progressBlock.querySelector('.progress-bar');
                                        if (progressBar) {
                                            progressBar.style.width = `${progressData.progress}%`;
                                            progressBar.setAttribute('aria-valuenow', progressData.progress);
                                        }
                                    }
                                })
                                .catch(err => console.log('Immediate progress check failed:', err));
                        }, 500);
                    }
                } else {
                    const errorBlocks = [{
                        type: 'info',
                        title: '‚ùå Processing Error',
                        content: data.error || 'Unknown error occurred',
                        color: 'danger'
                    }];
                    appendMessage('assistant', 'An error occurred while processing your request.', errorBlocks);
                }
            }
            try {
                await doRequest();
            } catch (e) {
                // quick retry once after brief backoff
                try {
                    await new Promise(r => setTimeout(r, 500));
                    await doRequest();
                } catch (e2) {
                    hideTyping();
                    const errorBlocks = [{
                        type: 'info',
                        title: 'üîå Network Error',
                        content: `Connection failed: ${e2.message || 'Network request failed'}`,
                        color: 'warning'
                    }];
                    appendMessage('assistant', 'Unable to connect to the server. Please check your connection.', errorBlocks);
                }
            } finally {
                isThinking = false;
                updateSendState();
                inputEl.focus();
            }
        }

        sendBtn.addEventListener('click', sendMessage);
        inputEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (!isThinking) sendMessage();
            }
        });
        inputEl.addEventListener('input', () => updateSendState());
        // no clear button

        // UI blocks test - uncomment to debug
        /*
        setTimeout(() => {
            const testBlocks = [
                {
                    type: 'metric',
                    title: 'System Health',
                    value: '9/16',
                    subtitle: 'Services running',
                    color: 'warning'
                },
                {
                    type: 'list',
                    title: 'Unhealthy Services',
                    items: ['flink-taskmanager', 'kafka', 'minio']
                }
            ];
            appendMessage('assistant', 'Test UI blocks:', testBlocks);
        }, 2000);
        */

        // Warm welcome message
        appendMessage('assistant', 'Ready to help with your data platform. Try: "run stavanger parking pipeline", "system status", or "pull latest data".', undefined);

        // Autofocus input on page load
        document.addEventListener('DOMContentLoaded', function () {
            inputEl.focus();
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>


